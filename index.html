<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apposite - Immersive Apps</title>
  <meta property="og:title" content="Apposite - Immersive Apps">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://www.apposite.ai/images/forest-ledge-wireframe.png">
  <link href="images/favicon.png" rel="shortcut icon" type="image/x-icon">
  <link href="images/favicon.png" rel="apple-touch-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&family=Darker+Grotesque:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-bg: #faf9f7;
      --color-bg-alt: #f3f1ed;
      --color-text: #1a1918;
      --color-text-muted: #6b6560;
      --color-text-subtle: #9e9890;
      --color-accent: #c4492f;
      --color-border: rgba(26, 25, 24, 0.08);
      --font-serif: 'Cormorant Garamond', Georgia, serif;
      --font-sans: 'Darker Grotesque', -apple-system, sans-serif;
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      font-size: 16px;
      scroll-behavior: smooth;
      background: var(--color-bg);
    }

    body {
      font-family: var(--font-sans);
      background: var(--color-bg);
      color: var(--color-text);
      line-height: 1.6;
      overflow-x: hidden;
      font-weight: 400;
    }


    ::selection {
      background: var(--color-accent);
      color: white;
    }

    /* Metaballs Canvas */
    #metaballs-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: auto;
      cursor: grab;
      background: var(--color-bg);
    }

    #metaballs-canvas:active {
      cursor: grabbing;
    }

    /* Main content */
    main {
      position: relative;
      z-index: 2;
      pointer-events: none;
    }

    main > * {
      pointer-events: auto;
    }

    /* Navigation */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 2rem 3rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      background: transparent;
      transition: background 0.5s ease, backdrop-filter 0.5s ease;
    }

    nav.scrolled {
      background: rgba(250, 249, 247, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }

    nav > * {
      pointer-events: auto;
    }

    .logo {
      font-family: var(--font-sans);
      font-size: 0.8rem;
      font-weight: 500;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--color-text);
      text-decoration: none;
      opacity: 0;
      animation: fadeIn 1s var(--ease-out-expo) 0.3s forwards;
      transition: color 0.4s ease;
    }

    .nav-links {
      display: flex;
      gap: 3rem;
      list-style: none;
    }

    .nav-links a {
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--color-text-muted);
      text-decoration: none;
      opacity: 0;
      animation: fadeIn 1s var(--ease-out-expo) forwards;
      position: relative;
      transition: color 0.4s ease;
    }

    .nav-links a:hover {
      color: var(--color-text);
    }

    .nav-links li:nth-child(1) a { animation-delay: 0.4s; }
    .nav-links li:nth-child(2) a { animation-delay: 0.5s; }
    .nav-links li:nth-child(3) a { animation-delay: 0.6s; }
    .nav-links li:nth-child(4) a { animation-delay: 0.7s; }

    .nav-links a::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 0;
      width: 0;
      height: 1px;
      background: var(--color-text);
      transition: width 0.4s var(--ease-out-expo);
    }

    .nav-links a:hover::after {
      width: 100%;
    }

    /* Mobile Menu */
    .nav-toggle {
      display: none;
      flex-direction: column;
      gap: 5px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      z-index: 101;
    }

    .nav-toggle span {
      width: 20px;
      height: 1.5px;
      background: var(--color-text);
      transition: all 0.3s ease;
    }

    .nav-toggle.active span:nth-child(1) {
      transform: rotate(45deg) translate(4px, 5px);
    }

    .nav-toggle.active span:nth-child(2) {
      opacity: 0;
    }

    .nav-toggle.active span:nth-child(3) {
      transform: rotate(-45deg) translate(4px, -5px);
    }

    /* Hero */
    .hero {
      min-height: 100vh;
      display: grid;
      grid-template-columns: 1fr 1fr;
      position: relative;
      pointer-events: none;
    }

    .hero-content {
      padding: 12rem 3rem 6rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      position: relative;
      z-index: 10;
      max-width: 600px;
    }

    .hero-label {
      font-family: var(--font-sans);
      font-size: 0.7rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.25em;
      color: var(--color-text-subtle);
      margin-bottom: 2.5rem;
      opacity: 0;
      animation: slideUp 1s var(--ease-out-expo) 0.5s forwards;
    }

    .hero h1 {
      font-family: var(--font-serif);
      font-size: clamp(2.5rem, 5vw, 4rem);
      font-weight: 300;
      line-height: 1.15;
      letter-spacing: -0.02em;
      margin-bottom: 2rem;
      opacity: 0;
      animation: slideUp 1s var(--ease-out-expo) 0.6s forwards;
    }

    .hero h1 em {
      font-style: italic;
      font-weight: 300;
      color: var(--color-accent);
    }

    .hero-description {
      font-family: var(--font-sans);
      font-size: 1.1rem;
      font-weight: 400;
      color: var(--color-text-muted);
      line-height: 1.7;
      max-width: 440px;
      opacity: 0;
      animation: slideUp 1s var(--ease-out-expo) 0.7s forwards;
    }

    .hero-cta {
      margin-top: 3.5rem;
      display: flex;
      gap: 2rem;
      align-items: center;
      opacity: 0;
      animation: slideUp 1s var(--ease-out-expo) 0.8s forwards;
    }

    .btn {
      font-family: var(--font-sans);
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      text-decoration: none;
      transition: all 0.4s var(--ease-out-expo);
      position: relative;
    }

    .btn-primary {
      color: var(--color-text);
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--color-text);
    }

    .btn-primary:hover {
      color: var(--color-accent);
      border-color: var(--color-accent);
    }

    .btn-secondary {
      color: var(--color-text-muted);
    }

    .btn-secondary:hover {
      color: var(--color-text);
    }

    .scroll-cue {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
      text-decoration: none;
      color: var(--color-text-muted);
      font-family: var(--font-sans);
      font-size: 0.7rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-top: 3.5rem;
      transition: color 0.3s ease;
    }

    .scroll-cue:hover {
      color: var(--color-text);
    }

    .scroll-cue svg {
      width: 20px;
      height: 20px;
      animation: bobDown 2s ease-in-out infinite;
    }

    @keyframes bobDown {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(6px); }
    }

    .hero-metaballs {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Interaction hint */
    .interaction-hint {
      position: absolute;
      bottom: 3rem;
      right: 3rem;
      font-family: var(--font-sans);
      font-size: 0.65rem;
      font-weight: 500;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--color-text-subtle);
      opacity: 0;
      animation: fadeIn 1s var(--ease-out-expo) 1.5s forwards;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      pointer-events: auto;
      z-index: 10;
    }

    .interaction-hint::before {
      content: '';
      width: 32px;
      height: 1px;
      background: var(--color-text-subtle);
    }

    /* Below fold background */
    .below-fold-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--color-bg);
      z-index: -1;
    }

    /* Immersive Section */
    .immersive-section {
      position: relative;
      min-height: 100vh;
      overflow: hidden;
      background: linear-gradient(to bottom, #b8b4ae 0%, #a8a49e 40%, #888480 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .immersive-layers {
      position: absolute;
      inset: 0;
      overflow: hidden;
    }

    .immersive-layer {
      position: absolute;
      left: -10%;
      right: -10%;
      width: 120%;
      background-repeat: repeat-x;
      will-change: transform;
    }

    .immersive-bg {
      bottom: 30%;
      height: 50vh;
      background-image: url('images/immersive-forest-background.png');
      background-size: auto 100%;
      background-position: center bottom;
      z-index: 1;
    }

    .immersive-mist-mid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
      opacity: 0.92;
      -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 70%, transparent 100%);
      mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 70%, transparent 100%);
    }

    .immersive-fg {
      bottom: 10%;
      height: 70vh;
      background-image: url('images/immersive-forest-midground.png');
      background-size: auto 100%;
      background-position: center bottom;
      z-index: 3;
    }

    .immersive-mist-front {
      position: absolute;
      bottom: 10%;
      left: 0;
      width: 100%;
      height: 50%;
      z-index: 4;
      pointer-events: none;
      opacity: 0.92;
      -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 30%, black 100%);
      mask-image: linear-gradient(to bottom, transparent 0%, black 30%, black 100%);
    }

    .immersive-content {
      position: relative;
      z-index: 10;
      text-align: center;
      padding: 4rem;
      max-width: 700px;
    }

    .immersive-label {
      font-family: var(--font-sans);
      font-size: 0.65rem;
      font-weight: 500;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 2rem;
      opacity: 0;
      transition: opacity 1.8s var(--ease-out-expo);
    }

    .immersive-title {
      font-family: var(--font-sans);
      font-size: clamp(3rem, 8vw, 5rem);
      font-weight: 300;
      color: white;
      letter-spacing: -0.02em;
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 40px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transition: opacity 2.3s var(--ease-out-expo) 0.1s;
    }

    .immersive-body {
      opacity: 0;
      transition: opacity 2.3s var(--ease-out-expo) 0.2s;
    }

    .immersive-desc {
      font-family: var(--font-sans);
      font-size: 1.1rem;
      font-weight: 400;
      color: rgba(255, 255, 255, 0.85);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      text-shadow: 0 1px 20px rgba(0, 0, 0, 0.2);
    }

    .immersive-link {
      font-family: var(--font-sans);
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: white;
      text-decoration: none;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.5);
      transition: border-color 0.4s ease;
    }

    .immersive-link:hover {
      border-color: white;
    }

    /* Animate in when section is visible */
    .immersive-section.in-view .immersive-label,
    .immersive-section.in-view .immersive-title,
    .immersive-section.in-view .immersive-body {
      opacity: 1;
    }

    /* Work Section */
    #work {
      padding: 10rem 3rem;
      background: var(--color-bg);
      position: relative;
    }

    .work-header {
      padding: 0;
      margin-bottom: 5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .work-title {
      font-family: var(--font-sans);
      font-size: clamp(1.5rem, 3vw, 2rem);
      font-weight: 500;
      letter-spacing: -0.01em;
    }

    .work-count {
      font-family: var(--font-sans);
      font-size: 0.7rem;
      font-weight: 500;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--color-text-subtle);
    }

    /* Project grid with images */
    .projects-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 3rem;
    }

    .project-item {
      position: relative;
    }

    .project-link {
      display: block;
      text-decoration: none;
      color: inherit;
      position: relative;
      overflow: hidden;
    }

    .project-image {
      width: 100%;
      aspect-ratio: 16/10;
      overflow: hidden;
      position: relative;
    }

    .project-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.8s var(--ease-out-expo), filter 0.5s ease;
    }

    .project-link:hover .project-image img {
      transform: scale(1.05);
    }

    .project-image-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(26, 25, 24, 0.7) 0%, transparent 50%);
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .project-link:hover .project-image-overlay {
      opacity: 1;
    }

    .project-info {
      padding: 1.5rem 0 2rem;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .project-content {
      flex: 1;
    }

    .project-meta {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.5rem;
    }

    .project-number {
      font-family: var(--font-sans);
      font-size: 0.7rem;
      font-weight: 500;
      color: var(--color-text-subtle);
    }

    .project-tag {
      font-family: var(--font-sans);
      font-size: 0.65rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--color-text-subtle);
    }

    .project-name {
      font-family: var(--font-sans);
      font-size: 1.35rem;
      font-weight: 500;
      letter-spacing: -0.01em;
      margin-bottom: 0.5rem;
      transition: color 0.3s ease;
    }

    .project-link:hover .project-name {
      color: var(--color-accent);
    }

    .project-desc {
      font-family: var(--font-sans);
      font-size: 0.9rem;
      font-weight: 400;
      color: var(--color-text-muted);
      line-height: 1.6;
      max-width: 360px;
    }

    .project-arrow {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-left: 1.5rem;
      transition: all 0.4s var(--ease-out-expo);
    }

    .project-arrow svg {
      width: 16px;
      height: 16px;
      stroke: var(--color-text-muted);
      transition: stroke 0.3s ease, transform 0.4s var(--ease-out-expo);
    }

    .project-link:hover .project-arrow {
      border-color: var(--color-accent);
      background: var(--color-accent);
    }

    .project-link:hover .project-arrow svg {
      stroke: white;
      transform: translate(1px, -1px);
    }

    /* Explore All Apps CTA card */
    .project-item-cta {
      display: flex;
      align-items: stretch;
    }

    .project-link-cta {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2rem;
      width: 100%;
      aspect-ratio: 16/10;
      background: var(--color-bg-alt);
      border-radius: 2px;
    }

    .app-icons-cluster {
      position: relative;
      width: 140px;
      height: 80px;
    }

    .app-icon {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 14px;
      background: var(--color-bg-alt);
      border: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.4s var(--ease-out-expo);
    }

    .app-icon svg {
      width: 24px;
      height: 24px;
      stroke: var(--color-text-muted);
    }

    .app-icon-1 {
      left: 0;
      top: 12px;
      z-index: 1;
    }

    .app-icon-2 {
      left: 42px;
      top: 0;
      z-index: 2;
    }

    .app-icon-3 {
      left: 84px;
      top: 12px;
      z-index: 1;
    }

    .project-link-cta:hover .app-icon-1 {
      transform: translateX(-4px);
    }

    .project-link-cta:hover .app-icon-2 {
      transform: translateY(-4px);
    }

    .project-link-cta:hover .app-icon-3 {
      transform: translateX(4px);
    }

    .explore-apps-label {
      font-family: var(--font-sans);
      font-size: 0.8rem;
      font-weight: 500;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--color-text-muted);
      transition: color 0.3s ease;
    }

    .project-link-cta:hover .explore-apps-label {
      color: var(--color-text);
    }

    /* Quote Section */
    .quote-section {
      position: relative;
      padding: 10rem 4rem;
      background: var(--color-bg-alt);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      cursor: default;
    }

    .quote-section canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .quote-section blockquote {
      position: relative;
      z-index: 1;
      max-width: 900px;
      font-family: var(--font-serif);
      font-size: clamp(1.5rem, 3vw, 2.25rem);
      font-weight: 300;
      font-style: italic;
      line-height: 1.7;
      text-align: center;
      color: var(--color-text);
      user-select: none;
      -webkit-user-select: none;
      transition: opacity 2.5s ease;
    }

    .quote-section .quote-text {
    }

    .quote-section.playing blockquote {
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .quote-section blockquote .play-hint {
      text-decoration: underline;
      text-decoration-color: var(--color-accent);
      text-underline-offset: 4px;
      transition: background 0.2s ease, color 0.2s ease;
      cursor: pointer;
    }

    .quote-section blockquote .play-hint:hover {
      color: var(--color-accent);
    }


    /* Studio Section */
    #studio {
      position: relative;
      min-height: 60vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .studio-bg {
      position: absolute;
      inset: 0;
      z-index: 0;
    }

    .studio-bg img {
      width: 100%;
      height: 140%;
      object-fit: cover;
      object-position: center 50%;
      will-change: transform, filter;
      transition: filter 0.1s ease-out;
    }

    .studio-content {
      position: relative;
      z-index: 1;
      text-align: center;
      padding: 6rem 3rem;
      max-width: 700px;
      transition: opacity 0.15s ease-out;
    }

    .studio-label {
      font-family: var(--font-sans);
      font-size: 0.65rem;
      font-weight: 500;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 1.5rem;
    }

    .studio-content h2 {
      font-family: var(--font-serif);
      font-size: clamp(1.75rem, 4vw, 2.5rem);
      font-weight: 300;
      font-style: italic;
      line-height: 1.4;
      letter-spacing: 0;
      margin-bottom: 2rem;
      color: white;
    }

    .studio-text {
      font-family: var(--font-sans);
      font-size: 1rem;
      font-weight: 400;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.8;
      max-width: 500px;
      margin: 0 auto 1.5rem;
    }

    .studio-link {
      font-family: var(--font-sans);
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      transition: color 0.3s ease;
    }

    .studio-link:hover {
      color: white;
    }

    /* Interests Section */
    .interests {
      padding: 8rem 4rem;
      background: var(--color-bg-alt);
      border-top: 1px solid var(--color-border);
    }

    .interests-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      margin-bottom: 4rem;
      max-width: 1400px;
      margin-left: auto;
      margin-right: auto;
    }

    .interests-title {
      font-family: var(--font-sans);
      font-size: 1.25rem;
      font-weight: 500;
      letter-spacing: -0.01em;
    }

    .interests-list {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem 2rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .interest-item {
      font-family: var(--font-sans);
      font-size: 0.9rem;
      font-weight: 400;
      color: var(--color-text-muted);
      padding: 0.75rem 0;
      border-bottom: 1px solid transparent;
      transition: all 0.3s ease;
      cursor: default;
    }

    .interest-item:hover {
      color: var(--color-text);
      border-color: var(--color-text);
    }

    /* Contact Section */
    #contact {
      padding: 12rem 4rem;
      background: var(--color-text);
      color: var(--color-bg);
      text-align: center;
    }

    .contact-label {
      font-family: var(--font-sans);
      font-size: 0.65rem;
      font-weight: 500;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      color: var(--color-text-subtle);
      margin-bottom: 2rem;
    }

    #contact h2 {
      font-family: var(--font-sans);
      font-size: clamp(1.75rem, 4vw, 2.5rem);
      font-weight: 500;
      letter-spacing: -0.01em;
      margin-bottom: 1.5rem;
    }

    #contact p {
      font-family: var(--font-sans);
      font-size: 1.1rem;
      font-weight: 400;
      color: var(--color-text-subtle);
      max-width: 500px;
      margin: 0 auto 3rem;
      line-height: 1.7;
    }

    .contact-email {
      font-family: var(--font-sans);
      font-size: 1.25rem;
      font-weight: 500;
      color: var(--color-bg);
      text-decoration: none;
      position: relative;
      transition: color 0.3s ease;
    }

    .contact-email::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 0;
      width: 100%;
      height: 1px;
      background: var(--color-bg);
      transform: scaleX(0);
      transform-origin: right;
      transition: transform 0.4s var(--ease-out-expo);
    }

    .contact-email:hover::after {
      transform: scaleX(1);
      transform-origin: left;
    }

    /* Footer */
    footer {
      position: relative;
      z-index: 2;
      padding: 2rem 4rem;
      background: var(--color-bg);
      border-top: 1px solid var(--color-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .footer-left {
      font-family: var(--font-sans);
      font-size: 0.7rem;
      font-weight: 400;
      letter-spacing: 0.1em;
      color: var(--color-text-muted);
    }

    .footer-links {
      display: flex;
      gap: 2.5rem;
    }

    .footer-links a {
      font-family: var(--font-sans);
      font-size: 0.7rem;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--color-text-muted);
      text-decoration: none;
      transition: color 0.3s ease;
    }

    .footer-links a:hover {
      color: var(--color-text);
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .hero {
        grid-template-columns: 1fr;
      }

      .hero-content {
        padding: 10rem 2rem 6rem;
        max-width: none;
      }

      #studio {
        min-height: 60vh;
      }

      .studio-content {
        padding: 4rem 2rem;
      }

      .projects-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      nav {
        padding: 1.5rem 2rem;
      }

      .nav-toggle {
        display: flex;
      }

      .nav-links {
        position: fixed;
        top: 0;
        right: 0;
        width: 100%;
        height: 100vh;
        background: var(--color-bg);
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 2.5rem;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .nav-links.active {
        opacity: 1;
        visibility: visible;
      }

      .nav-links a {
        font-size: 1rem;
        color: var(--color-text);
      }

      .work-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }

      #work {
        padding: 10rem 2rem;
      }

      .project-info {
        padding: 1.5rem 0;
        flex-direction: column;
      }

      .project-arrow {
        margin-left: 0;
        margin-top: 1rem;
      }

      #studio,
      .quote-section,
      .interests,
      #contact {
        padding-left: 2rem;
        padding-right: 2rem;
      }

      footer {
        flex-direction: column;
        gap: 1.5rem;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <canvas id="metaballs-canvas"></canvas>

  <nav>
    <a href="#" class="logo">Apposite</a>
    <button class="nav-toggle" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <ul class="nav-links">
      <li><a href="apps.html">Apps</a></li>
      <li><a href="immersive.html">Immersive</a></li>
      <li><a href="support.html">Support</a></li>
      <li><a href="about.html">About</a></li>
    </ul>
  </nav>

  <main>
    <section class="hero">
      <div class="hero-content">
        <p class="hero-label">Creative Technology Studio</p>
        <h1>Creative, <em>immersive</em> apps.</h1>
        <p class="hero-description">Spatial software, creative tools, immersive worlds. Featured by Apple. Hand crafted by an independent studio in the Pacific Northwest.</p>
        <a href="#immersive" class="scroll-cue">
          <span>Explore</span>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M12 5v14M5 12l7 7 7-7"/>
          </svg>
        </a>
      </div>
      <div class="hero-metaballs"></div>
      <div class="interaction-hint">
        <span>Drag to interact</span>
      </div>
    </section>

    <section id="immersive" class="immersive-section">
      <div class="immersive-layers">
        <div class="immersive-layer immersive-bg" data-parallax-speed="0.3"></div>
        <canvas id="mist-canvas-mid" class="immersive-mist-mid"></canvas>
        <div class="immersive-layer immersive-fg" data-parallax-speed="0.15"></div>
        <canvas id="mist-canvas-front" class="immersive-mist-front"></canvas>
      </div>
      <div class="immersive-content">
        <p class="immersive-label">Apple Vision Pro</p>
        <h2 class="immersive-title">Immersive</h2>
        <div class="immersive-body">
          <p class="immersive-desc">We're pioneering the art of spatial environments—creating breathtaking immersive experiences for Apple Vision Pro that rival Apple's own million-dollar productions.</p>
          <a href="immersive.html" class="immersive-link">See How We Build Worlds</a>
        </div>
      </div>
    </section>

    <section id="work">
      <div class="below-fold-bg"></div>
      <div class="work-header">
        <h2 class="work-title">Selected Work</h2>
        <span class="work-count">Featured by Apple</span>
      </div>

      <div class="projects-grid">
        <article class="project-item">
          <a href="vibescape.html" class="project-link">
            <div class="project-image">
              <img src="images/vibescape2.jpeg" alt="Vibescape immersive environment">
              <div class="project-image-overlay"></div>
            </div>
            <div class="project-info">
              <div class="project-content">
                <div class="project-meta">
                  <span class="project-number">01</span>
                  <span class="project-tag">visionOS</span>
                </div>
                <h3 class="project-name">Vibescape</h3>
                <p class="project-desc">Immersive environments for Vision Pro that have been compared to Apple's own multi-million dollar productions.</p>
              </div>
              <div class="project-arrow">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M7 17L17 7M17 7H7M17 7V17"/>
                </svg>
              </div>
            </div>
          </a>
        </article>

        <article class="project-item">
          <a href="polychord.html" class="project-link">
            <div class="project-image">
              <img src="images/polychord-detail.jpg" alt="Polychord music app">
              <div class="project-image-overlay"></div>
            </div>
            <div class="project-info">
              <div class="project-content">
                <div class="project-meta">
                  <span class="project-number">02</span>
                  <span class="project-tag">iPad</span>
                </div>
                <h3 class="project-name">Polychord</h3>
                <p class="project-desc">Award-winning iPad musical instrument loved by professionals and novices alike.</p>
              </div>
              <div class="project-arrow">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M7 17L17 7M17 7H7M17 7V17"/>
                </svg>
              </div>
            </div>
          </a>
        </article>

        <article class="project-item">
          <a href="metaballs.html" class="project-link">
            <div class="project-image">
              <img src="images/metaballsNew.jpg" alt="Metaballs spatial app">
              <div class="project-image-overlay"></div>
            </div>
            <div class="project-info">
              <div class="project-content">
                <div class="project-meta">
                  <span class="project-number">03</span>
                  <span class="project-tag">visionOS</span>
                </div>
                <h3 class="project-name">Metaballs</h3>
                <p class="project-desc">Play with blobs and create organic forms in this fun spatial modeling app for Vision Pro.</p>
              </div>
              <div class="project-arrow">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M7 17L17 7M17 7H7M17 7V17"/>
                </svg>
              </div>
            </div>
          </a>
        </article>

        <article class="project-item project-item-cta">
          <a href="apps.html" class="project-link project-link-cta">
            <div class="app-icons-cluster">
              <div class="app-icon app-icon-1">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM21 16c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2z"/>
                </svg>
              </div>
              <div class="app-icon app-icon-2">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <circle cx="12" cy="12" r="10"/>
                  <circle cx="12" cy="12" r="4"/>
                  <circle cx="12" cy="12" r="1"/>
                </svg>
              </div>
              <div class="app-icon app-icon-3">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z"/>
                  <circle cx="12" cy="12" r="3"/>
                </svg>
              </div>
            </div>
            <span class="explore-apps-label">Explore All Apps</span>
          </a>
        </article>
      </div>
    </section>

    <section class="quote-section" id="quote-section">
      <canvas id="fluid-dots"></canvas>
      <blockquote>
        <span class="quote-text">The goal of our work is to move people. Provide them with a beautiful experience. To remind them of the value of <span class="play-hint">play</span>.</span>
      </blockquote>
    </section>

    <section id="studio">
      <div class="studio-bg">
        <img src="images/colleen-studio.png" alt="Colleen in the studio">
      </div>
      <div class="studio-content">
        <p class="studio-label">The Studio</p>
        <h2>Somewhere in the woods of the Pacific Northwest</h2>
        <p class="studio-text">
          An indie studio on 80 acres in Oregon, making spatial software and immersive worlds.
        </p>
        <a href="about.html" class="studio-link">Learn more about Apposite</a>
      </div>
    </section>

    <section class="interests">
      <div class="interests-header">
        <h3 class="interests-title">Things We're Into</h3>
      </div>
      <div class="interests-list">
        <span class="interest-item">Procedural environments in Houdini</span>
        <span class="interest-item">Zen garden design principles</span>
        <span class="interest-item">Metal & GPU-driven rendering</span>
        <span class="interest-item">Photogrammetry & spatial capture</span>
        <span class="interest-item">Music making & audio synthesis</span>
        <span class="interest-item">Sketching & visual thinking</span>
        <span class="interest-item">Nature & landscape restoration</span>
        <span class="interest-item">Making-of & process videos</span>
      </div>
    </section>

    <section id="contact">
      <p class="contact-label">Get in Touch</p>
      <h2>Believe in what we're making?</h2>
      <p>We're always looking for collaborators, clients who share our values, and people who want to support independent creative software.</p>
      <a href="mailto:hello@apposite.ai" class="contact-email">hello@apposite.ai</a>
    </section>

  </main>

  <footer>
    <div class="footer-left">
      © 2025 Apposite
    </div>
    <div class="footer-links">
      <a href="https://youtube.com/@dreamwieber">YouTube</a>
    </div>
  </footer>

  <script>
    // WebGL Metaballs
    const canvas = document.getElementById('metaballs-canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    if (!gl) {
      console.warn('WebGL not supported');
    }

    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision highp float;

      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec2 u_mouse;
      uniform float u_mouseInfluence;
      uniform float u_scrollY;
      uniform vec2 u_ballOffsets[5];

      #define MAX_STEPS 64
      #define MAX_DIST 100.0
      #define SURF_DIST 0.001
      #define NUM_BALLS 5

      vec3 ballPositions[NUM_BALLS];
      float ballRadii[NUM_BALLS];

      void initBalls() {
        float t = u_time * 0.25;

        // Shifted ~20% left from original
        ballPositions[0] = vec3(1.1 + sin(t * 0.7) * 0.5, sin(t * 0.5) * 0.7, -3.0 + cos(t * 0.3) * 0.8);
        ballPositions[1] = vec3(1.8 + cos(t * 0.6) * 0.6, 0.4 + sin(t * 0.8) * 0.5, -3.3 + sin(t * 0.4) * 0.6);
        ballPositions[2] = vec3(0.8 + sin(t * 0.9) * 0.4, -0.3 + cos(t * 0.7) * 0.6, -2.7 + cos(t * 0.5) * 0.5);
        ballPositions[3] = vec3(1.5 + cos(t * 0.5) * 0.5, 0.7 + sin(t * 0.6) * 0.4, -3.1 + sin(t * 0.6) * 0.6);
        ballPositions[4] = vec3(0.5 + sin(t * 0.8) * 0.5, -0.1 + cos(t * 0.9) * 0.5, -3.6 + cos(t * 0.7) * 0.5);

        ballRadii[0] = 0.55;
        ballRadii[1] = 0.42;
        ballRadii[2] = 0.48;
        ballRadii[3] = 0.32;
        ballRadii[4] = 0.38;
      }

      float smin(float a, float b, float k) {
        float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
        return mix(b, a, h) - k * h * (1.0 - h);
      }

      float sdSphere(vec3 p, vec3 center, float radius) {
        return length(p - center) - radius;
      }

      float map(vec3 p) {
        float d = 1000.0;
        for (int i = 0; i < NUM_BALLS; i++) {
          vec3 pos = ballPositions[i];
          pos.x += u_ballOffsets[i].x;
          pos.y += u_ballOffsets[i].y;
          d = smin(d, sdSphere(p, pos, ballRadii[i]), 0.45);
        }
        return d;
      }

      vec3 getNormal(vec3 p) {
        float d = map(p);
        vec2 e = vec2(0.001, 0.0);
        vec3 n = d - vec3(
          map(p - e.xyy),
          map(p - e.yxy),
          map(p - e.yyx)
        );
        return normalize(n);
      }

      float rayMarch(vec3 ro, vec3 rd) {
        float dO = 0.0;
        for (int i = 0; i < MAX_STEPS; i++) {
          vec3 p = ro + rd * dO;
          float dS = map(p);
          dO += dS;
          if (dO > MAX_DIST || dS < SURF_DIST) break;
        }
        return dO;
      }

      void main() {
        initBalls();

        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

        vec3 ro = vec3(0.0, 0.0, 1.0);
        vec3 rd = normalize(vec3(uv, -1.0));

        vec3 col = vec3(0.98, 0.976, 0.965);
        col -= vec3(0.02, 0.015, 0.01) * length(uv) * 0.3;

        float d = rayMarch(ro, rd);

        if (d < MAX_DIST) {
          vec3 p = ro + rd * d;
          vec3 n = getNormal(p);

          vec3 baseColor = vec3(0.9, 0.9, 0.9) * 0.5;

          vec3 lightPos1 = vec3(3.0, 4.0, 3.0);
          vec3 lightPos2 = vec3(-3.0, 2.0, 4.0);
          vec3 lightPos3 = vec3(0.0, -3.0, 2.0);

          vec3 lightDir1 = normalize(lightPos1 - p);
          vec3 lightDir2 = normalize(lightPos2 - p);
          vec3 lightDir3 = normalize(lightPos3 - p);

          vec3 viewDir = normalize(ro - p);

          float diff1 = max(dot(n, lightDir1), 0.0);
          float diff2 = max(dot(n, lightDir2), 0.0);
          float diff3 = max(dot(n, lightDir3), 0.0);

          vec3 reflectDir1 = reflect(-lightDir1, n);
          vec3 reflectDir2 = reflect(-lightDir2, n);

          float spec1 = pow(max(dot(viewDir, reflectDir1), 0.0), 16.0);
          float spec2 = pow(max(dot(viewDir, reflectDir2), 0.0), 24.0);

          float fresnel = pow(1.0 - max(dot(viewDir, n), 0.0), 2.5);

          vec3 ambient = vec3(0.95, 0.92, 0.88) * 0.9;
          vec3 diffuse = baseColor * (diff1 * 0.5 + diff2 * 0.25 + diff3 * 0.15) + ambient;

          vec3 specColor = vec3(1.0, 0.98, 0.95);
          vec3 specular = specColor * (spec1 * 0.2 + spec2 * 0.15);

          vec3 rimColor = vec3(0.98, 0.95, 0.90);
          vec3 rim = rimColor * fresnel * 0.25;

          col = diffuse + specular + rim;

          float ao = 0.6 + 0.4 * n.y;
          col *= ao;
        }

        float scrollFade = 1.0 - smoothstep(0.0, 1.2, u_scrollY);
        col = mix(vec3(0.98, 0.976, 0.965), col, scrollFade);

        float vignette = 1.0 - length(uv) * 0.15;
        col *= vignette;

        col = pow(col, vec3(0.4545));

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    const timeLocation = gl.getUniformLocation(program, 'u_time');
    const mouseLocation = gl.getUniformLocation(program, 'u_mouse');
    const mouseInfluenceLocation = gl.getUniformLocation(program, 'u_mouseInfluence');
    const scrollLocation = gl.getUniformLocation(program, 'u_scrollY');

    const ballOffsetLocations = [];
    for (let i = 0; i < 5; i++) {
      ballOffsetLocations.push(gl.getUniformLocation(program, `u_ballOffsets[${i}]`));
    }

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1, 1, -1, -1, 1,
      -1, 1, 1, -1, 1, 1
    ]), gl.STATIC_DRAW);

    let mouse = { x: 0.5, y: 0.5 };
    let isDragging = false;
    let isInHero = true;
    let grabbedBall = -1;
    let dragStart = { x: 0, y: 0 };
    let dragVelocity = { x: 0, y: 0 };
    let lastDragOffset = { x: 0, y: 0 };
    let grabBaseOffset = { x: 0, y: 0 };

    const NUM_BALLS = 5;
    const ballOffsets = Array(NUM_BALLS).fill(null).map(() => ({ x: 0, y: 0 }));
    const ballVelocities = Array(NUM_BALLS).fill(null).map(() => ({ x: 0, y: 0 }));

    function getBallPositions(time) {
      const t = time * 0.25;
      return [
        { x: 1.1 + Math.sin(t * 0.7) * 0.5, y: Math.sin(t * 0.5) * 0.7, z: -3.0 + Math.cos(t * 0.3) * 0.8, r: 0.55 },
        { x: 1.8 + Math.cos(t * 0.6) * 0.6, y: 0.4 + Math.sin(t * 0.8) * 0.5, z: -3.3 + Math.sin(t * 0.4) * 0.6, r: 0.42 },
        { x: 0.8 + Math.sin(t * 0.9) * 0.4, y: -0.3 + Math.cos(t * 0.7) * 0.6, z: -2.7 + Math.cos(t * 0.5) * 0.5, r: 0.48 },
        { x: 1.5 + Math.cos(t * 0.5) * 0.5, y: 0.7 + Math.sin(t * 0.6) * 0.4, z: -3.1 + Math.sin(t * 0.6) * 0.6, r: 0.32 },
        { x: 0.5 + Math.sin(t * 0.8) * 0.5, y: -0.1 + Math.cos(t * 0.9) * 0.5, z: -3.6 + Math.cos(t * 0.7) * 0.5, r: 0.38 }
      ];
    }

    function screenToRay(screenX, screenY) {
      const aspect = canvas.width / canvas.height;
      const uvX = (screenX / window.innerWidth - 0.5) * aspect;
      const uvY = (0.5 - screenY / window.innerHeight);
      return { x: uvX, y: uvY };
    }

    function projectToScreen(x, y, z) {
      const depth = 1.0 - z;
      return { x: x / depth, y: y / depth };
    }

    function hitTestBalls(screenX, screenY, time) {
      const ray = screenToRay(screenX, screenY);
      const balls = getBallPositions(time);

      const sortedBalls = balls.map((ball, i) => ({ ...ball, index: i }))
        .sort((a, b) => b.z - a.z);

      for (const ball of sortedBalls) {
        let ballX = ball.x + ballOffsets[ball.index].x;
        let ballY = ball.y + ballOffsets[ball.index].y;

        const projected = projectToScreen(ballX, ballY, ball.z);
        const projectedR = ball.r / (1.0 - ball.z) * 1.3;

        const dx = ray.x - projected.x;
        const dy = ray.y - projected.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < projectedR) {
          return ball.index;
        }
      }
      return -1;
    }

    function getWorldDragOffset(screenX, screenY, startScreenX, startScreenY, ballZ) {
      const current = screenToRay(screenX, screenY);
      const start = screenToRay(startScreenX, startScreenY);
      const depth = 1.0 - ballZ;
      return {
        x: (current.x - start.x) * depth,
        y: (current.y - start.y) * depth
      };
    }

    document.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX / window.innerWidth;
      mouse.y = e.clientY / window.innerHeight;

      isInHero = window.scrollY < window.innerHeight * 0.8;

      if (isDragging && grabbedBall >= 0) {
        const time = (Date.now() - startTime) / 1000;
        const balls = getBallPositions(time);
        const ball = balls[grabbedBall];

        const newOffset = getWorldDragOffset(e.clientX, e.clientY, dragStart.x, dragStart.y, ball.z);

        dragVelocity.x = dragVelocity.x * 0.7 + (newOffset.x - lastDragOffset.x) * 0.3;
        dragVelocity.y = dragVelocity.y * 0.7 + (newOffset.y - lastDragOffset.y) * 0.3;
        lastDragOffset.x = newOffset.x;
        lastDragOffset.y = newOffset.y;

        ballOffsets[grabbedBall].x = grabBaseOffset.x + newOffset.x;
        ballOffsets[grabbedBall].y = grabBaseOffset.y + newOffset.y;
      }
    });

    document.addEventListener('mousedown', (e) => {
      if (isInHero) {
        const time = (Date.now() - startTime) / 1000;
        const hitBall = hitTestBalls(e.clientX, e.clientY, time);

        if (hitBall >= 0) {
          isDragging = true;
          grabbedBall = hitBall;
          grabBaseOffset = { x: ballOffsets[hitBall].x, y: ballOffsets[hitBall].y };
          ballVelocities[hitBall].x = 0;
          ballVelocities[hitBall].y = 0;
          dragStart = { x: e.clientX, y: e.clientY };
          lastDragOffset = { x: 0, y: 0 };
          dragVelocity = { x: 0, y: 0 };
          canvas.style.cursor = 'grabbing';
        }
      }
    });

    function clampVelocity(vx, vy, maxSpeed) {
      const speed = Math.sqrt(vx * vx + vy * vy);
      if (speed > maxSpeed) {
        const scale = maxSpeed / speed;
        return { x: vx * scale, y: vy * scale };
      }
      return { x: vx, y: vy };
    }

    document.addEventListener('mouseup', () => {
      if (isDragging && grabbedBall >= 0) {
        const maxSpeed = 0.02;
        const clampedVel = clampVelocity(dragVelocity.x, dragVelocity.y, maxSpeed);
        ballVelocities[grabbedBall].x = clampedVel.x * 1.5;
        ballVelocities[grabbedBall].y = clampedVel.y * 1.5;
      }
      isDragging = false;
      grabbedBall = -1;
      canvas.style.cursor = 'grab';
    });

    document.addEventListener('mouseleave', () => {
      if (isDragging && grabbedBall >= 0) {
        const maxSpeed = 0.02;
        const clampedVel = clampVelocity(dragVelocity.x, dragVelocity.y, maxSpeed);
        ballVelocities[grabbedBall].x = clampedVel.x * 1.5;
        ballVelocities[grabbedBall].y = clampedVel.y * 1.5;
      }
      isDragging = false;
      grabbedBall = -1;
    });

    document.addEventListener('touchstart', (e) => {
      if (window.scrollY < window.innerHeight * 0.8) {
        const touch = e.touches[0];
        const time = (Date.now() - startTime) / 1000;
        const hitBall = hitTestBalls(touch.clientX, touch.clientY, time);

        if (hitBall >= 0) {
          e.preventDefault();
          isDragging = true;
          grabbedBall = hitBall;
          grabBaseOffset = { x: ballOffsets[hitBall].x, y: ballOffsets[hitBall].y };
          ballVelocities[hitBall].x = 0;
          ballVelocities[hitBall].y = 0;
          dragStart = { x: touch.clientX, y: touch.clientY };
          lastDragOffset = { x: 0, y: 0 };
          dragVelocity = { x: 0, y: 0 };
        }
      }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (isDragging && grabbedBall >= 0) {
        const touch = e.touches[0];
        const time = (Date.now() - startTime) / 1000;
        const balls = getBallPositions(time);
        const ball = balls[grabbedBall];

        const newOffset = getWorldDragOffset(touch.clientX, touch.clientY, dragStart.x, dragStart.y, ball.z);

        dragVelocity.x = dragVelocity.x * 0.7 + (newOffset.x - lastDragOffset.x) * 0.3;
        dragVelocity.y = dragVelocity.y * 0.7 + (newOffset.y - lastDragOffset.y) * 0.3;
        lastDragOffset.x = newOffset.x;
        lastDragOffset.y = newOffset.y;

        ballOffsets[grabbedBall].x = grabBaseOffset.x + newOffset.x;
        ballOffsets[grabbedBall].y = grabBaseOffset.y + newOffset.y;
      }
    });

    document.addEventListener('touchend', () => {
      if (isDragging && grabbedBall >= 0) {
        const maxSpeed = 0.02;
        const clampedVel = clampVelocity(dragVelocity.x, dragVelocity.y, maxSpeed);
        ballVelocities[grabbedBall].x = clampedVel.x * 1.5;
        ballVelocities[grabbedBall].y = clampedVel.y * 1.5;
      }
      isDragging = false;
      grabbedBall = -1;
    });

    let scrollY = 0;
    const nav = document.querySelector('nav');

    // Immersive section parallax
    const immersiveSection = document.querySelector('.immersive-section');
    const immersiveBg = document.querySelector('.immersive-bg');
    const immersiveFg = document.querySelector('.immersive-fg');

    window.addEventListener('scroll', () => {
      scrollY = window.scrollY / window.innerHeight;

      // Toggle nav background when scrolled past hero
      if (window.scrollY > 100) {
        nav.classList.add('scrolled');
      } else {
        nav.classList.remove('scrolled');
      }

      // Parallax for immersive section
      if (immersiveSection) {
        const rect = immersiveSection.getBoundingClientRect();
        const inView = rect.top < window.innerHeight && rect.bottom > 0;

        // Trigger text fade-in when section is well into view
        if (rect.top < window.innerHeight * 0.3) {
          immersiveSection.classList.add('in-view');
        }

        if (inView) {
          const progress = (window.innerHeight - rect.top) / (window.innerHeight + rect.height);
          // Parallax - bg moves slow (far), fg moves more (near) - 15% stronger
          const bgOffset = (progress - 0.5) * -115;
          const fgOffset = (progress - 0.5) * -317;
          const mistMidOffset = (progress - 0.5) * -173;

          if (immersiveBg) immersiveBg.style.transform = `translateY(${bgOffset}px)`;
          if (immersiveFg) immersiveFg.style.transform = `translateY(${fgOffset}px)`;

          // Label moves just a hair more than background forest layer
          const immersiveLabel = document.querySelector('.immersive-label');
          if (immersiveLabel) immersiveLabel.style.transform = `translateY(${bgOffset * 1.15}px)`;

          // Foreground text moves just a hair more than foreground forest layer
          const fgTextOffset = fgOffset * 1.12;
          const immersiveTitle = document.querySelector('.immersive-title');
          const immersiveBody = document.querySelector('.immersive-body');
          if (immersiveTitle) immersiveTitle.style.transform = `translateY(${fgTextOffset}px)`;
          // Desc and link grouped in body container - move together
          if (immersiveBody) immersiveBody.style.transform = `translateY(${fgTextOffset}px)`;

          // Also move mist layers
          const mistMid = document.getElementById('mist-canvas-mid');
          const mistFront = document.getElementById('mist-canvas-front');
          if (mistMid) mistMid.style.transform = `translateY(${mistMidOffset}px)`;
          if (mistFront) mistFront.style.transform = `translateY(${fgOffset * 0.4}px)`;

        }
      }
    });

    function resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    window.addEventListener('resize', resize);
    resize();

    let startTime = Date.now();
    let lastFrameTime = Date.now();

    function render() {
      const time = (Date.now() - startTime) / 1000;
      const deltaTime = Math.min((Date.now() - lastFrameTime) / 1000, 0.05);
      lastFrameTime = Date.now();

      const friction = 0.995;
      const returnStrength = 0.004;
      const maxReturnForce = 0.00025;

      for (let i = 0; i < NUM_BALLS; i++) {
        if (i === grabbedBall) continue;

        const distX = -ballOffsets[i].x;
        const distY = -ballOffsets[i].y;

        let returnForceX = distX * returnStrength * deltaTime;
        let returnForceY = distY * returnStrength * deltaTime;

        const returnForceMag = Math.sqrt(returnForceX * returnForceX + returnForceY * returnForceY);
        if (returnForceMag > maxReturnForce) {
          const scale = maxReturnForce / returnForceMag;
          returnForceX *= scale;
          returnForceY *= scale;
        }

        ballVelocities[i].x += returnForceX;
        ballVelocities[i].y += returnForceY;
        ballVelocities[i].x *= friction;
        ballVelocities[i].y *= friction;
        ballOffsets[i].x += ballVelocities[i].x;
        ballOffsets[i].y += ballVelocities[i].y;

        if (Math.abs(ballOffsets[i].x) < 0.001 &&
            Math.abs(ballOffsets[i].y) < 0.001 &&
            Math.abs(ballVelocities[i].x) < 0.0001 &&
            Math.abs(ballVelocities[i].y) < 0.0001) {
          ballOffsets[i].x = 0;
          ballOffsets[i].y = 0;
          ballVelocities[i].x = 0;
          ballVelocities[i].y = 0;
        }
      }

      gl.useProgram(program);

      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(timeLocation, time);
      gl.uniform2f(mouseLocation, mouse.x, mouse.y);
      gl.uniform1f(mouseInfluenceLocation, isDragging ? 1.0 : 0.0);
      gl.uniform1f(scrollLocation, scrollY);

      for (let i = 0; i < NUM_BALLS; i++) {
        gl.uniform2f(ballOffsetLocations[i], ballOffsets[i].x, ballOffsets[i].y);
      }

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    render();

    // Animated Mist for Immersive Section
    (function() {
      const mistCanvasMid = document.getElementById('mist-canvas-mid');
      const mistCanvasFront = document.getElementById('mist-canvas-front');

      if (!mistCanvasMid || !mistCanvasFront) return;

      const ctxMid = mistCanvasMid.getContext('2d');
      const ctxFront = mistCanvasFront.getContext('2d');

      // Simplex noise implementation (fast, smooth)
      const grad3 = [
        [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
        [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
        [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
      ];

      const perm = new Uint8Array(512);
      const permMod12 = new Uint8Array(512);

      // Seed the permutation
      for (let i = 0; i < 256; i++) {
        perm[i] = perm[i + 256] = (i * 131 + 17) % 256;
        permMod12[i] = permMod12[i + 256] = perm[i] % 12;
      }

      function dot2(g, x, y) {
        return g[0] * x + g[1] * y;
      }

      const F2 = 0.5 * (Math.sqrt(3) - 1);
      const G2 = (3 - Math.sqrt(3)) / 6;

      function simplex2D(x, y) {
        const s = (x + y) * F2;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = x - X0;
        const y0 = y - Y0;

        let i1, j1;
        if (x0 > y0) { i1 = 1; j1 = 0; }
        else { i1 = 0; j1 = 1; }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;

        const ii = i & 255;
        const jj = j & 255;

        let n0 = 0, n1 = 0, n2 = 0;

        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
          t0 *= t0;
          n0 = t0 * t0 * dot2(grad3[permMod12[ii + perm[jj]]], x0, y0);
        }

        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
          t1 *= t1;
          n1 = t1 * t1 * dot2(grad3[permMod12[ii + i1 + perm[jj + j1]]], x1, y1);
        }

        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
          t2 *= t2;
          n2 = t2 * t2 * dot2(grad3[permMod12[ii + 1 + perm[jj + 1]]], x2, y2);
        }

        return 70 * (n0 + n1 + n2);
      }

      // Fractional Brownian Motion for richer noise
      function fbm(x, y, octaves) {
        let value = 0;
        let amplitude = 0.5;
        let frequency = 1;
        for (let i = 0; i < octaves; i++) {
          value += amplitude * simplex2D(x * frequency, y * frequency);
          amplitude *= 0.5;
          frequency *= 2;
        }
        return value;
      }

      let mistWidth, mistHeight;
      const scale = 0.3; // Render at lower res for performance

      function resizeMistCanvases() {
        const section = document.querySelector('.immersive-section');
        if (!section) return;

        const rect = section.getBoundingClientRect();
        mistWidth = Math.floor(rect.width * scale);
        mistHeight = Math.floor(rect.height * scale);

        // Mid mist - full coverage with soft falloff in rendering
        mistCanvasMid.width = mistWidth;
        mistCanvasMid.height = mistHeight;
        mistCanvasMid.style.width = rect.width + 'px';
        mistCanvasMid.style.height = rect.height + 'px';

        // Front mist - lower portion
        mistCanvasFront.width = mistWidth;
        mistCanvasFront.height = Math.floor(rect.height * 0.4 * scale);
        mistCanvasFront.style.width = rect.width + 'px';
        mistCanvasFront.style.height = (rect.height * 0.4) + 'px';
      }

      resizeMistCanvases();
      window.addEventListener('resize', resizeMistCanvases);

      let mistTime = 0;
      let lastMistFrame = Date.now();

      function renderMist() {
        const now = Date.now();
        const delta = (now - lastMistFrame) / 1000;
        lastMistFrame = now;
        mistTime += delta * 0.44; // More noticeable drift

        // Check if section is in view
        const section = document.querySelector('.immersive-section');
        if (!section) {
          requestAnimationFrame(renderMist);
          return;
        }

        const rect = section.getBoundingClientRect();
        const inView = rect.top < window.innerHeight && rect.bottom > 0;

        if (!inView) {
          requestAnimationFrame(renderMist);
          return;
        }

        // Mid-ground mist (between bg and fg forests)
        const imgDataMid = ctxMid.createImageData(mistWidth, mistHeight);
        const dataMid = imgDataMid.data;

        for (let y = 0; y < mistHeight; y++) {
          const ny = y / mistHeight;
          // Concentrate mist in middle band with very soft edges
          const centerY = 0.55;  // Moved down 10%
          const spread = 0.35;
          const distFromCenter = Math.abs(ny - centerY) / spread;
          const vertFade = Math.max(0, 1 - distFromCenter * distFromCenter);

          for (let x = 0; x < mistWidth; x++) {
            const nx = x / mistWidth;

            // Multi-layered noise for soft, cloudy look - 5% higher frequency, slightly faster
            const noise1 = fbm(nx * 2.1 + mistTime * 0.55, ny * 1.575 + mistTime * 0.22, 3);
            const noise2 = fbm(nx * 4.2 - mistTime * 0.4, ny * 2.625 + mistTime * 0.12, 2);
            const combined = (noise1 * 0.6 + noise2 * 0.4 + 1) * 0.5;

            // Soft threshold for cloud-like appearance
            const mist = Math.pow(combined, 1.3) * vertFade;

            const idx = (y * mistWidth + x) * 4;
            dataMid[idx] = 255;     // R
            dataMid[idx + 1] = 255; // G
            dataMid[idx + 2] = 255; // B
            dataMid[idx + 3] = Math.floor(mist * 100); // A - subtle
          }
        }

        ctxMid.putImageData(imgDataMid, 0, 0);

        // Front mist (rising from bottom)
        const frontHeight = mistCanvasFront.height;
        if (frontHeight > 0) {
          const imgDataFront = ctxFront.createImageData(mistWidth, frontHeight);
          const dataFront = imgDataFront.data;

          for (let y = 0; y < frontHeight; y++) {
            const ny = y / frontHeight;
            // Strong fade from bottom (opaque) to top (transparent)
            const vertFade = Math.pow(1 - ny, 2);

            for (let x = 0; x < mistWidth; x++) {
              const nx = x / mistWidth;

              // Drifting, billowy noise
              const noise1 = fbm(nx * 3 + mistTime * 0.6, ny * 2 - mistTime * 0.25, 3);
              const noise2 = fbm(nx * 5 - mistTime * 0.4, ny * 3 + mistTime * 0.15, 2);
              const combined = (noise1 * 0.5 + noise2 * 0.5 + 1) * 0.5;

              const mist = combined * vertFade;

              const idx = (y * mistWidth + x) * 4;
              dataFront[idx] = 255;     // R
              dataFront[idx + 1] = 255; // G
              dataFront[idx + 2] = 255; // B
              dataFront[idx + 3] = Math.floor(mist * 180); // A - more opaque at bottom
            }
          }

          ctxFront.putImageData(imgDataFront, 0, 0);
        }

        requestAnimationFrame(renderMist);
      }

      renderMist();
    })();
  </script>

  <script>
    // Studio section parallax and darken on scroll
    (function() {
      const studio = document.getElementById('studio');
      const studioBg = studio?.querySelector('.studio-bg img');
      const studioContent = studio?.querySelector('.studio-content');

      if (!studio || !studioBg) return;

      function updateStudio() {
        const rect = studio.getBoundingClientRect();
        const windowHeight = window.innerHeight;

        // Calculate how far into view the section is (0 = just entering, 1 = fully visible)
        const progress = Math.max(0, Math.min(1, 1 - (rect.top / windowHeight)));

        // Parallax: move image slower than scroll (reduced effect)
        const parallaxOffset = rect.top * 0.15;
        studioBg.style.transform = `translateY(${parallaxOffset}px)`;

        // Darken image as section scrolls into view (brightness goes from 1 to 0.45)
        const brightness = 1 - (progress * 0.55);
        studioBg.style.filter = `brightness(${brightness})`;

        // Fade in content
        if (studioContent) {
          studioContent.style.opacity = Math.min(1, progress * 1.5);
        }
      }

      // Initial state
      if (studioContent) studioContent.style.opacity = 0;

      window.addEventListener('scroll', updateStudio, { passive: true });
      updateStudio();
    })();
  </script>

  <script>
    // Fluid dots effect for quote section
    (function() {
      const canvas = document.getElementById('fluid-dots');
      const section = document.getElementById('quote-section');
      if (!canvas || !section) return;

      const ctx = canvas.getContext('2d');
      let grid = [];
      let cols, rows;
      const spacing = 35;
      const maxRadius = 5;
      const mouseRadius = 80;
      const spreadRate = 0.15;
      const decay = 0.92;
      const energyDecay = 0.005;

      let mouse = { x: -1000, y: -1000, prevX: -1000, prevY: -1000 };
      let sectionRect = section.getBoundingClientRect();
      let animating = false;
      let isPlaying = false;
      let isDragging = false;
      let ripples = [];
      let mouseDownPos = { x: 0, y: 0 };
      let didDrag = false;
      let hasClicked = false;
      let idleTimeout = null;
      let justEntered = false;

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        sectionRect = section.getBoundingClientRect();
        canvas.width = sectionRect.width * dpr;
        canvas.height = sectionRect.height * dpr;
        ctx.scale(dpr, dpr);
        initGrid();
      }

      function initGrid() {
        cols = Math.floor(sectionRect.width / spacing);
        rows = Math.floor(sectionRect.height / spacing);

        // Center the grid within the section
        const offsetX = (sectionRect.width - (cols - 1) * spacing) / 2;
        const offsetY = (sectionRect.height - (rows - 1) * spacing) / 2;

        grid = [];

        for (let i = 0; i < cols; i++) {
          grid[i] = [];
          for (let j = 0; j < rows; j++) {
            grid[i][j] = {
              x: offsetX + i * spacing,
              y: offsetY + j * spacing,
              energy: 0,
              velocity: 0
            };
          }
        }
      }

      function simulate() {
        // Create new grid for next state
        const newGrid = [];
        for (let i = 0; i < cols; i++) {
          newGrid[i] = [];
          for (let j = 0; j < rows; j++) {
            newGrid[i][j] = { ...grid[i][j], velocity: grid[i][j].velocity };
          }
        }

        // Spread energy to neighbors (fluid diffusion)
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            const cell = grid[i][j];
            let neighborSum = 0;
            let neighborCount = 0;

            // Check 4 neighbors
            const neighbors = [
              [i-1, j], [i+1, j], [i, j-1], [i, j+1]
            ];

            for (const [ni, nj] of neighbors) {
              if (ni >= 0 && ni < cols && nj >= 0 && nj < rows) {
                neighborSum += grid[ni][nj].energy;
                neighborCount++;
              }
            }

            // Diffusion: blend toward neighbor average
            const neighborAvg = neighborSum / neighborCount;
            const diff = neighborAvg - cell.energy;
            newGrid[i][j].velocity += diff * spreadRate;
            newGrid[i][j].velocity *= decay;
            newGrid[i][j].energy += newGrid[i][j].velocity;

            // Constant decay so dots fade out
            newGrid[i][j].energy -= energyDecay;

            // Clamp
            if (newGrid[i][j].energy < 0.01) newGrid[i][j].energy = 0;
            if (newGrid[i][j].energy > 1) newGrid[i][j].energy = 1;
          }
        }

        grid = newGrid;
      }

      function addRipple(x, y) {
        ripples.push({ x, y, radius: 0, speed: 8 });
      }

      function addEnergy() {
        // Calculate mouse velocity
        const mouseVelX = mouse.x - mouse.prevX;
        const mouseVelY = mouse.y - mouse.prevY;
        const mouseSpeed = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);

        // Process ripples
        for (let r = ripples.length - 1; r >= 0; r--) {
          const ripple = ripples[r];
          ripple.radius += ripple.speed;

          // Remove ripples that have expanded beyond the section
          if (ripple.radius > Math.max(sectionRect.width, sectionRect.height)) {
            ripples.splice(r, 1);
            continue;
          }

          // Add energy in a thin ring around the ripple
          const ringWidth = 25;
          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              const cell = grid[i][j];
              const dx = ripple.x - cell.x;
              const dy = ripple.y - cell.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              // Check if cell is within the ripple ring (between inner and outer edge)
              const distFromRing = Math.abs(dist - ripple.radius);
              if (distFromRing < ringWidth) {
                // Sharper falloff at edges, peak in the middle of the ring
                const influence = 1 - (distFromRing / ringWidth);
                const sharpInfluence = influence * influence * influence;
                const boost = sharpInfluence * 0.15;
                cell.energy = Math.min(1, cell.energy + boost);
                cell.velocity += boost * 0.2;
              }
            }
          }
        }

        // Only add energy when mouse is moving (or just entered)
        if (mouseSpeed > 2 || justEntered) {
          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              const cell = grid[i][j];
              const dx = mouse.x - cell.x;
              const dy = mouse.y - cell.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist < mouseRadius) {
                const influence = 1 - (dist / mouseRadius);
                let boost = influence * influence * 0.2;

                // Extra energy when clicking/dragging
                if (isDragging) {
                  boost *= 2;
                  // Impart directional velocity based on mouse movement
                  const velBoost = influence * mouseSpeed * 0.02;
                  cell.velocity += velBoost;
                }

                cell.energy = Math.min(1, cell.energy + boost);
                cell.velocity += boost * 0.5;
              }
            }
          }
        }

        mouse.prevX = mouse.x;
        mouse.prevY = mouse.y;
      }

      function render() {
        ctx.clearRect(0, 0, sectionRect.width, sectionRect.height);

        addEnergy();
        simulate();

        let hasEnergy = false;

        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            const cell = grid[i][j];

            if (cell.energy > 0.005) {
              hasEnergy = true;

              // Soft exclusion zone around center (where text is) - only when not playing
              let exclusionFade = 1;
              if (!isPlaying) {
                const centerX = sectionRect.width / 2;
                const centerY = sectionRect.height / 2;
                const dx = cell.x - centerX;
                const dy = cell.y - centerY;

                // Elliptical zone (wider than tall to match text shape)
                const zoneWidth = 420;
                const zoneHeight = 100;
                const distNorm = Math.sqrt((dx * dx) / (zoneWidth * zoneWidth) + (dy * dy) / (zoneHeight * zoneHeight));

                // Soft fade: 1 outside zone, fades to 0 inside
                exclusionFade = Math.min(1, Math.max(0, (distNorm - 0.5) * 2));
              }

              const radius = maxRadius * cell.energy;
              const opacity = 0.85 * cell.energy * exclusionFade;

              if (opacity > 0.01) {
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, radius, 0, Math.PI * 2);
                const color = hasClicked ? `rgba(196, 73, 47, ${opacity})` : `rgba(215, 210, 200, ${opacity})`;
                ctx.fillStyle = color;
                ctx.fill();
              }
            }
          }
        }

        if (hasEnergy || ripples.length > 0) {
          animating = true;
          requestAnimationFrame(render);
        } else {
          animating = false;
        }
      }

      function startAnimation() {
        if (!animating) {
          animating = true;
          render();
        }
      }

      function exitPlayMode() {
        if (isPlaying) {
          isPlaying = false;
          hasClicked = false;
          section.classList.remove('playing');
        }
      }

      function resetIdleTimer() {
        if (idleTimeout) clearTimeout(idleTimeout);
        idleTimeout = setTimeout(exitPlayMode, 2500);
      }

      section.addEventListener('mouseenter', (e) => {
        sectionRect = section.getBoundingClientRect();
        mouse.x = e.clientX - sectionRect.left;
        mouse.y = e.clientY - sectionRect.top;
        mouse.prevX = mouse.x - 5; // Fake a small movement to trigger dots
        mouse.prevY = mouse.y;
        justEntered = true;
        startAnimation();
        // Clear the flag after a moment
        setTimeout(() => { justEntered = false; }, 100);
      });

      section.addEventListener('mousemove', (e) => {
        sectionRect = section.getBoundingClientRect();
        mouse.prevX = mouse.x;
        mouse.prevY = mouse.y;
        mouse.x = e.clientX - sectionRect.left;
        mouse.y = e.clientY - sectionRect.top;

        // Check if user is dragging (moved more than 10px from mousedown)
        if (isDragging && !didDrag) {
          const dx = mouse.x - mouseDownPos.x;
          const dy = mouse.y - mouseDownPos.y;
          if (Math.sqrt(dx * dx + dy * dy) > 10) {
            didDrag = true;
          }
        }

        // Reset idle timer when mouse moves
        if (isPlaying) {
          resetIdleTimer();
        }

        startAnimation();
      });

      section.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isDragging = true;
        didDrag = false;
        hasClicked = true;
        sectionRect = section.getBoundingClientRect();
        mouseDownPos.x = e.clientX - sectionRect.left;
        mouseDownPos.y = e.clientY - sectionRect.top;
        if (!isPlaying) {
          isPlaying = true;
          section.classList.add('playing');
        }
        resetIdleTimer();
        startAnimation();
      });

      section.addEventListener('mouseup', (e) => {
        // Only create ripple if it was a click (not a drag)
        if (!didDrag) {
          sectionRect = section.getBoundingClientRect();
          addRipple(e.clientX - sectionRect.left, e.clientY - sectionRect.top);
          hasClicked = true;
        }
        isDragging = false;
      });

      section.addEventListener('mouseleave', () => {
        mouse.x = -1000;
        mouse.y = -1000;
        isDragging = false;
        // Don't immediately exit - let the idle timer handle it gracefully
        resetIdleTimer();
      });

      // Touch support
      section.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        sectionRect = section.getBoundingClientRect();
        mouse.x = touch.clientX - sectionRect.left;
        mouse.y = touch.clientY - sectionRect.top;
        mouse.prevX = mouse.x;
        mouse.prevY = mouse.y;
        mouseDownPos.x = mouse.x;
        mouseDownPos.y = mouse.y;
        isDragging = true;
        didDrag = false;
        hasClicked = true;
        if (!isPlaying) {
          isPlaying = true;
          section.classList.add('playing');
        }
        resetIdleTimer();
        startAnimation();
      }, { passive: false });

      section.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        sectionRect = section.getBoundingClientRect();
        mouse.prevX = mouse.x;
        mouse.prevY = mouse.y;
        mouse.x = touch.clientX - sectionRect.left;
        mouse.y = touch.clientY - sectionRect.top;

        if (!didDrag) {
          const dx = mouse.x - mouseDownPos.x;
          const dy = mouse.y - mouseDownPos.y;
          if (Math.sqrt(dx * dx + dy * dy) > 10) {
            didDrag = true;
          }
        }

        resetIdleTimer();
        startAnimation();
      }, { passive: false });

      section.addEventListener('touchend', (e) => {
        if (!didDrag) {
          addRipple(mouse.x, mouse.y);
        }
        isDragging = false;
      });

      window.addEventListener('resize', resize);
      resize();
    })();
  </script>

  <script>
    // Mobile nav toggle
    const navToggle = document.querySelector('.nav-toggle');
    const navLinks = document.querySelector('.nav-links');

    navToggle.addEventListener('click', () => {
      navToggle.classList.toggle('active');
      navLinks.classList.toggle('active');
    });

    // Close menu when clicking a link
    navLinks.querySelectorAll('a').forEach(link => {
      link.addEventListener('click', () => {
        navToggle.classList.remove('active');
        navLinks.classList.remove('active');
      });
    });
  </script>
</body>
</html>
